---
output: github_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%"
)
```

# jpgrid <a href="https://uchidamizuki.github.io/jpgrid/"><img src="man/figures/logo.png" align="right" height="139" /></a>

<!-- badges: start -->
[![CRAN status](https://www.r-pkg.org/badges/version/jpgrid)](https://CRAN.R-project.org/package=jpgrid)
<!-- badges: end -->

jpgrid is an R package for using the reference regional mesh (the 1st mesh to the 3rd mesh), the split regional mesh as defined by the JIS (Japan Industrial Standard) X 0410 '
[Grid Square Code](https://www.jisc.go.jp/app/jis/general/GnrJISNumberNameSearchList?show&jisStdNo=X0410)' 
and 1/10 subdivision of the 3rd mesh.
Grid Square Codes are square-like regional divisions set up for all regions of Japan based on longitude and latitude. For more information on regional meshes, please check [the Statistics Bureau of Japan page](https://www.stat.go.jp/data/mesh/pdf/gaiyo1.pdf).

A summary of the Grid Square Codes is shown below. In jpgrid, each regional mesh code is distinguished by the length of a piece of mesh, such as `grid_80km`.

```{r,echo=FALSE}
df <- tibble::tibble(`Name` = c("1st mesh", "2nd mesh", "3rd mesh", "1/2 mesh", "1/4 mesh", "1/8 mesh", "1/10 subdivision of the 3rd mesh"),
                     `Edge length` = c("Abount 80km", "Abount 10km", "Abount 1km", "Abount 500m", "Abount 250m", "Abount 125m", "Abount 100m"),
                     `Number of digits` = c(4, 6, 8, 9, 10, 11, 10))
knitr::kable(df)
```

jpgrid has been developed to enable faster processing than the R package [jpmesh](https://github.com/uribo/jpmesh).
The main differences between jpgrid and jpmesh are as follows

1. Explicitly given a mesh size (such as `grid_80km`). 
2. Non-land (ocean) meshes are supported.
3. It can extract nth-order neighboring meshes and perform complex operations such as extracting meshes and calculating the distance of (line) paths between meshes.

## Installation

You can install jpgrid from CRAN.

``` r
install.packages("jpgrid")
```

You can also install the development version from GitHub.

``` r
# install.packages("devtools")
devtools::install_github("UchidaMizuki/jpgrid")
```
## Usage

```{r,message=FALSE,warning=FALSE}
library(jpgrid)

library(tibble)
library(dplyr)
library(ggplot2)
```

### Generation of Grid Square Codes from character strings or numbers

Use `grid_parse()` to generate Grid Square Codes from strings or numbers.

- Specify the grid size as `grid_size = "80km"`.
  - If `grid_size = NULL`, the grid size is automatically determined.
- The default (`strict = TRUE`) requires the mesh codes to have a given number of digits.

```{r}
x <- c("53394526313", "5339358633", "533945764", "53394611", "523503", "5339", NA)

grid_parse(x, grid_size = "80km")
grid_parse(x, grid_size = "125m")
grid_parse(x)

grid_parse(x, "80km",
           strict = FALSE)
grid_parse(x, "125m",
           strict = FALSE)
grid_parse(x, 
           strict = FALSE)
```

### Converting the mesh size of Grid Square Codes

Use `grid_convert()` to coarsen the mesh size of Grid Square Codes.
The `grid_subdivide()` function can be used to subdivide Grid Square Codes.

- `grid_subdivide()` outputs a list of mesh codes whose elements are contained in the original meshes.
- The conversion between 500m mesh and 100m mesh is supported.

```{r}
grid_500m <- grid_parse("533945764", "500m")

grid_convert(grid_500m, "1km")

grid_100m <- grid_subdivide(grid_500m, "100m")
grid_100m

tibble(grid_100m = grid_100m[[1]]) |> 
  grid_as_sf() |>  
  ggplot() +
  geom_sf() +
  geom_sf_text(aes(label = as.character(grid_100m)))
```

### Conversion of geometry to Grid Square Codes

`grid_from_geom()` can be used to convert `sf` objects to regional mesh codes.
You can also use `grid_as_sf()` to convert data containing a regional mesh (of class `grid`) into an `sf` object.

```{r}
geom_chiba <- rnaturalearth::ne_states(country = "japan",
                                       returnclass = "sf") |> 
  filter(name == "Chiba")
grid_chiba <- grid_from_geom(geom_chiba, "10km") |> 
  first() |> 
  grid_as_sf(crs = sf::st_crs(geom_chiba))

grid_chiba |> 
  ggplot() +
  geom_sf(data = geom_chiba) +
  geom_sf(fill = "transparent") +
  geom_sf_text(aes(label = as.character(grid)),
               size = 2)
```

### Conversion from longitude/latitude to Grid Square Codes

The `grid_from_coords()` converts longitude and latitude to Grid Square Codes.

```{r}
tibble(X = c(139.7008, 135.4375), # longitude
       Y = c(35.68906, 34.70833)) |> # latitude
  mutate(grid_100m = grid_from_coords(X, Y, "100m"),
         grid_125m = grid_from_coords(X, Y, "125m")) |> 
  knitr::kable()
```

### Conversion from Grid Square Codes to longitude/latitude

The `grid_to_coords()` function converts Grid Square Codes to longitude and latitude.

```{r}
tibble(grid = grid_100m(c("5339452660", "5235034590"))) |> 
  mutate(grid_to_coords(grid)) |> 
  knitr::kable()
```

### Calculation of adjacent mesh codes

The `grid_neighbor()` function calculates the neighboring meshes.

- nth order neighboring meshes can be calculated by specifying `n`.
- Can be calculated in a Neumann neighborhood with `moore = FALSE`.

```{r}
neighbor <- grid_parse("644142", "10km") |> 
  grid_neighbor(n = c(0:2),
                simplify = FALSE)

neighbor[[1]] |> 
  grid_as_sf() |> 
  
  ggplot(aes(fill = as.factor(n))) +
  geom_sf() +
  geom_sf_text(aes(label = as.character(grid_neighbor)))
```

```{r}
neighbor_neumann <- grid_parse("644142", "10km") |> 
  grid_neighbor(n = c(0:2),
                simplify = F,
                moore = F)

neighbor_neumann[[1]] |> 
  grid_as_sf() |> 
  ggplot(aes(fill = as.factor(n))) +
  geom_sf() +
  geom_sf_text(aes(label = as.character(grid_neighbor)))
```

### Draw line segments between meshes

The `grid_line()` function extracts meshes that lie on the line segments between meshes.

```{r}
grid_from <- grid_parse(c("6441", "5339"), "80km")
grid_to <- grid_parse(c("5237", "5235"), "80km")

line <- grid_line(grid_from, grid_to)

tibble::tibble(grid = line[[1]]) |> 
  grid_as_sf() |> 
  ggplot() +
  geom_sf() +
  geom_sf_text(aes(label = as.character(grid)))
```

It can handle the case of passing through multiple meshes by giving a `list` of meshes.

- Close the line segment with `close = TRUE`.
- `skip_na = TRUE` to skip `NA`.

```{r}
grid_1 <- grid_parse(c("6441", "5339", NA, "5250"), "80km")
grid_2 <- grid_parse(c("6439", "5211", "4013", "6635"), "80km")

line <- grid_line(list(grid_1, grid_2), 
                  close = TRUE,
                  skip_na = TRUE)

tibble::tibble(grid = line[[1]]) |> 
  grid_as_sf() |> 
  ggplot() +
  geom_sf() +
  geom_sf_text(aes(label = as.character(grid)))
```

### Calculation of distance between meshes

The `grid_distance()` function calculates the distance between meshes (great circle distance).

- As with `grid_line()`, the path distance can be calculated by `list` of meshes.

```{r}
grid_from <- grid_parse(c("6441", "5339"), "80km")
grid_to <- grid_parse(c("5237", "5235"), "80km")

distance <- grid_distance(grid_from, grid_to)

print(distance)
```

### Others
- `grid_move()` function can be used to calculate regional meshes in the east-west and north-south directions.
- For meshes outside the range of the 80 km mesh, where the digits are negative or exceed three digits, the relevant code is displayed as `<-1>` or `<123>` to clearly distinguish them from existing meshes.

## Comparison of processing speed with jpmesh package

The conversion speed between meshes and latitude/longitude in this package is several tens to several hundred times faster than in the jpmesh package.

```{r,echo=FALSE,message=FALSE}
set.seed(1234)
X <- runif(1e1, 139, 140)
Y <- runif(1e1, 39, 40)

microbenchmark::microbenchmark(`jpgrid::grid_from_coords()` = grid_from_coords(X, Y, "1km"),
                               `jpmesh::coords_to_mesh()` = jpmesh::coords_to_mesh(X, Y,
                                                                                   mesh_size = 1),
                               setup = set.seed(1234)) |> 
  autoplot()
```

```{r,echo=FALSE,message=FALSE}
set.seed(1234)
X <- runif(1e1, 139, 140)
Y <- runif(1e1, 39, 40)
grid_jpgrid <- grid_from_coords(X, Y, "1km")
mesh_jpmesh <- jpmesh::coords_to_mesh(X, Y, 
                                      mesh_size = 1)

microbenchmark::microbenchmark(`jpgrid::grid_to_coords()` = grid_to_coords(grid_jpgrid),
                               `jpmesh::mesh_to_coords()` = jpmesh::mesh_to_coords(mesh_jpmesh),
                               setup = set.seed(1234)) |> 
  autoplot()
```
